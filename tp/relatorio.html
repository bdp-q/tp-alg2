<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Relatorio</title>
</head>
<body>
    <div style="text-align: center;" >
        <h1>Relatório</h1>
        <p><em>Relatório do trabalho da disciplina de Algoritmos 2 ministrada pelo professor <a href= "https://www.inf.ufpr.br/elias/" target="_blank">Elias P. Duarte Jr.</a></em></p>
    </div>
    <h2>Organização</h2>
    <hr>    
    <p>feito por: Breno Demio Padilha e Haico de Toledo Boehs.</p>

    <p>O trabalho foi separado em 4 arquivos diferentes:</p>
    <ul>
        <li><b>ordenacao(.h e .c):</b> Que contêm as funções de algoritmos de ordenação;</li>
        <li><b>heap(.h e .c):</b> Que contêm as funções que compõe o TAD Heap;</li>
        <li><b>main.c:</b> Programa que possui a interface gráfica mais as funções que utilizam os algoritmos de ordenação;</li>
        <li><b>makefile:</b>Arquivo para compilar todos os arquivos de uma só vez, utilizando o comando "make".</li>
    </ul>
    <p><em> os arquivos foram todos feitos em conjunto e com constante conversa e discussão sobre nossas implementações, 
        mas o TAD Heap ficou principalmente com o Haico e o ordenação com o Breno, sendo a main.c construida um pouco por ambos.</em></p>
    <hr>
    <h2> Nossa implementação:</h2>
    <h3>Main</h3>
    O programa principal, que chama as funções contidas no ordenação.h e no heap.h possui a interface gráfica do nosso pronto socorro.
    Para isso, fizemos uso de um switch com varios cases, que são as opções que chamam e executam cada algoritmo.
    <p>Além disso, utilizamos funções dentro da main para criar a comparação dos algoritmos e para trabalhar com strings, por exemplo com a função <b>"LimpaBuffer"</b> 
        que criamos para resolver erros em lidar com scanf e strings, além de evitar certas entradas de quebrar o programa(um erro que tivemos no início do desenvolvimento foi que no nosso switch, se você digitasse caracteres o programa entrava num loop infinito).
    </p>
    Decidimos implementar 6 opções para a Enfermeira:

    <ul>
        <li><b>sair do programa:</b> quebra o while que mantém o programa rodando e o acaba.</li>
        <li><b>Inserir paciente (InsereHeap):</b></li>
        <li><b>Chamar próximo paciente (RemoveHeap):</b> </li>
        <li><b>Imprimir os pacientes (ImprimeHeap):</b>Arquivo para compilar todos os arquivos de uma só vez, utilizando o comando "make".</li>
        <li><b>alterar a prioridade de algum paciente:</b>Arquivo para compilar todos os arquivos de uma só vez, utilizando o comando "make".</li>
        <li><b>gerar vetor aleatório (ou de 32 ou de 1024 elementos):</b>Arquivo para compilar todos os arquivos de uma só vez, utilizando o comando "make".</li>

    </ul>

    
    <h3>Ordenação</h3>

    <p> As funções de ordenação foram feitas </p>


    <ol>
    <li>
        <a href=""></a>
    </li>
    <li>
        <a href="#Lnk">bar</a>
        <ol>
        <li>
            <a href="#Lnk">baz</a>
        </li>
        <li>
            <a href="#Lnk">qux</a>
        </li>
        </ol>
    </li>
    <li>
        <a href="#Lnk">alpha</a>
        <ol>
        <li>
            <a href="#Lnk">beta</a>
        </li>
        <li>
            <a href="#Lnk">gamma</a>
        </li>
        </ol>
    </li>
    </ol>

    <h3>TAD Heap</h3>
        <p>Implementamos o TAD Heap como um vetor de structs, com os campos nome (string) e prioridade (int).</p>
        <p>As seguintes funções foram implementadas para o TAD Heap:</p>
        <li>
            <b>InicHeap: </b>
            <p>Inicia a Heap, atribuindo 0 à váriavel que controla o tamanho do vetor e atribuindo valor nulo para suas posições; </p>

            <b>InsereHeap: </b>
            <p>Função utilizada para inserir um novo paciente na fila de prioridades. Cria um novo paciente a partir do nome e prioridade inseridos pela enfermeira e coloca no fim do vetor. Então, executa a função InsereHeapAUX, que leva o elemento a sua posição correta dentro do Heap. Também foi necessário implementar a função auxiliar copiaString, que manipula um vetor de char, para garantir que o nome do paciente fosse inserido corretamente.</p>

            <b>RemoveHeap</b>
            <p>Função usada para remover o paciente com maior prioridade. Primeiro checa se a lista é nula, caso seja, retorna 0. Caso contrário, o primeiro elemento do vetor recebe o valor do elemento da última posição e o tamanho é decrementado. Por fim, executa-se a função Heapfy para que a condição de Heap não seja violada. Retorna 1 caso a operação seja bem-sucedida.</p>

            <b>ImprimeHeap</b>
            <p>Função que imprime a Heap. Caso a Heap seja vazia, imprime "Heap Vazia". Caso contrário, imprime com o formato "Heap de Pacientes: (nome: ### | prio: ###) ...". </p>

            <b>AlteraHeap</b>
            <p>Altera a prioridade de um paciente selecionado na Heap. Permite que o usuário digite o nome e a prioridade atual de um paciente, caso ele não exista na fila, a função retorna 0. Caso exista, altera a prioridade conforme o input do usuário e verifica se a condição de Heap foi mantida. Se a Heap tiver sido violada, executa a função Heapfy. Para verificar a existência de um paciente, usamos a função auxiliar AchaPaciente, que por sua vez, itera sobre o vetor e compara a prioridade esperada com a prioridade do paciente atual. Também compara o nome do paciente, usando a função auxiliar ComparaString.   </p>

            <b>ChecaHeap</b>
            <p>Verifica se um vetor é uma Heap. Caso algum elemento do vetor não obedeça a condição heap[i] <= heap[2i] retorna 0. Se a heap for válida retorna 1. </p>

            <b>Heapfy</b>
            <p>Transforma um vetor genérico em heap. Percorre o vetor executando a função InsereHeapEF (igual a InsereHeapAUX, mas rastreia o número de comparações feitas pelo heapfy), ou seja, a cada iteração, aloca o elemento atual conforme sua prioridade na heap. </p>

            <b>Sacode Heap</b>
        </li>

</body>
</html>